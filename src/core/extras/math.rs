/*
  Example of basic modular arithmetic
  This is a main() file built to test math operations. D. Cousins
 */

use std::time::{Instant};

fn test_big_vector(nloop: usize) {
    println!("testing BigVector");
    let t1 = Instant::now();
    let t2 = Instant::now();
    let t3 = Instant::now();
    let time2: f64;

    let q1 = BigInteger::from(163841);
    let a1strvec = vec![
        "127753", "77706", "17133", "22582", "112132", "27625", "126773", "8924", "125972",
        "2551", "113837", "112045", "100953", "77352", "132013", "57029",
    ];
    let a1 = BigVector::from_slice(&a1strvec);
    a1.set_modulus(&q1);
    let b1strvec = vec![
        "66773", "69572", "142134", "141115", "123182", "155822", "128147", "94818", "135782",
        "30844", "88634", "99407", "53647", "111689", "28502", "26401",
    ];
    let b1 = BigVector::from_slice(&b1strvec);
    b1.set_modulus(&q1);
    let modsum1strvec = vec![
        "30685", "147278", "159267", "163697", "71473", "19606", "91079", "103742", "97913",
        "33395", "38630", "47611", "154600", "25200", "160515", "83430",
    ];
    let modsum1 = BigVector::from_slice(&modsum1strvec);
    modsum1.set_modulus(&q1);
    let moddiff1strvec = vec![
        "60980", "8134", "38840", "45308", "152791", "35644", "162467", "77947", "154031",
        "135548", "25203", "12638", "47306", "129504", "103511", "30628",
    ];
    let moddiff1 = BigVector::from_slice(&moddiff1strvec);
    moddiff1.set_modulus(&q1);
    let modmul1strvec = vec![
        "69404", "64196", "13039", "115321", "28519", "151998", "89117", "80908", "57386",
        "39364", "8355", "146135", "61336", "31598", "25961", "87680",
    ];
    let modmul1 = BigVector::from_slice(&modmul1strvec);
    modmul1.set_modulus(&q1);
    let mut c1 = BigVector::new();
    let mut c2 = BigVector::new();
    let mut c3 = BigVector::new();

    #[cfg(feature = "profile")]
    {
        let mut res: BigVector;
        let mut time2: f64;
        let mut j: usize;

        res = BigVector::new();
        for j in 0..nloop {
            res = a1.clone() + &b1;
        }
        time2 = t1.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t1", nloop, "res", "a1 + b1", time2
        );
        if res != modsum1 {
            println!("Bad res = a1 + b1");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a1.mod_add(&b1);
        }
        time2 = t1.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t1", nloop, "res", "a1.mod_add(b1)", time2
        );
        if res != modsum1 {
            println!("Bad res = a1.mod_add(b1)");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a1.clone() - &b1;
        }
        time2 = t1.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t1", nloop, "res", "a1 - b1", time2
        );
        if res != moddiff1 {
            println!("Bad res = a1 - b1");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a1.mod_sub(&b1);
        }
        time2 = t1.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t1", nloop, "res", "a1.mod_sub(b1)", time2
        );
        if res != moddiff1 {
            println!("Bad res = a1.mod_sub(b1)");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a1.clone() * &b1;
        }
        time2 = t1.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t1", nloop, "res", "a1 * b1", time2
        );
        if res != modmul1 {
            println!("Bad res = a1 * b1");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a1.mod_mul(&b1);
        }
        time2 = t1.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t1", nloop, "res", "a1.mod_mul(b1)", time2
        );
        if res != modmul1 {
            println!("Bad res = a1.mod_mul(b1)");
        }
    }

    let q2 = BigInteger::from(4057816419532801);
    let a2strvec = vec![
        "185225172798255", "98879665709163", "3497410031351258", "4012431933509255",
        "1543020758028581", "135094568432141", "3976954337141739", "4030348521557120",
        "175940803531155", "435236277692967", "33046526490670144", "2032520019613814",
        "375749152798379", "3933203511673255", "2293434116159938", "1201413067178193",
    ];
    let a2 = BigVector::from_slice(&a2strvec);
    a2.set_modulus(&q2);
    let b2strvec = vec![
        "698898215124963", "39832572186149", "1835473200214782", "1041547470449968",
        "1076152419903743", "433588874877196", "2336100673132075", "2990190360138614",
        "754647536064726", "702097990733190", "2102063768035483", "119786389165930",
        "3976652902630043", "3238750424196678", "2978742255253796", "2124827461185795",
    ];
    let b2 = BigVector::from_slice(&b2strvec);
    b2.set_modulus(&q2);
    let modsum2strvec = vec![
        "884123387923218", "138712237895312", "1275066812033239", "996162984426422",
        "2619173177932324", "568683443309337", "2255238590741013", "2962722462162933",
        "930588339595881", "1137334268426841", "1348899997572826", "2152306408779744",
        "294585635895621", "1214359951880933", "1214359951880933", "3326240528363988",
    ];
    let modsum2 = BigVector::from_slice(&modsum2strvec);
    modsum2.set_modulus(&q2);
    let moddiff2strvec = vec![
        "3544143377206093", "59047093523014", "1661936831136476", "2970884463059287",
        "466868338124838", "3759322113087746", "1640853664009664", "1040158161161418",
        "3479109686999230", "3790954706492578", "1202588881034661", "1912733630430488",
        "456912669701137", "694453087476577", "3372508280438943", "3134402025525199",
    ];
    let moddiff2 = BigVector::from_slice(&moddiff2strvec);
    moddiff2.set_modulus(&q2);
    let modmul2strvec = vec![
        "585473140075497", "3637571624495703", "1216097920193708", "1363577444007558",
        "694070384788800", "2378590980295198", "903406520872185", "559510929662632",
        "322863634303789", "1685429502680940", "1715852907773825", "2521152917532260",
        "781959737898673", "2334258943108700", "2573793300043944", "1273980645866111",
    ];
    let modmul2 = BigVector::from_slice(&modmul2strvec);
    modmul2.set_modulus(&q2);

    #[cfg(feature = "profile")]
    {
        let mut res: BigVector;
        let mut time2: f64;
        let mut j: usize;

        res = BigVector::new();
        for j in 0..nloop {
            res = a2.clone() + &b2;
        }
        time2 = t2.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t2", nloop, "res", "a2 + b2", time2
        );
        if res != modsum2 {
            println!("Bad res = a2 + b2");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a2.mod_add(&b2);
        }
        time2 = t2.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t2", nloop, "res", "a2.mod_add(b2)", time2
        );
        if res != modsum2 {
            println!("Bad res = a2.mod_add(b2)");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a2.clone() - &b2;
        }
        time2 = t2.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t2", nloop, "res", "a2 - b2", time2
        );
        if res != moddiff2 {
            println!("Bad res = a2 - b2");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a2.mod_sub(&b2);
        }
        time2 = t2.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t2", nloop, "res", "a2.mod_sub(b2)", time2
        );
        if res != moddiff2 {
            println!("Bad res = a2.mod_sub(b2)");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a2.clone() * &b2;
        }
        time2 = t2.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t2", nloop, "res", "a2 * b2", time2
        );
        if res != modmul2 {
            println!("Bad res = a2 * b2");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a2.mod_mul(&b2);
        }
        time2 = t2.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t2", nloop, "res", "a2.mod_mul(b2)", time2
        );
        if res != modmul2 {
            println!("Bad res = a2.mod_mul(b2)");
        }
    }

    let q3 = BigInteger::from_dec_str(
        "3273390607896141870013189696827599152216642046043064789483291368096133796404674554883270092325904157150886684127560071009217256545885393053328527589431",
    )
    .unwrap();
    let a3strvec = vec![
        "2259002487796164904665772121894078584543401744155154298312726209247751689172189255653866355964200768484575418973864307364757237946940733747446643725054",
        "1478743816308009734668992873633380110912159803397999015955212019971253231528589466789603074746010444199132421555598329082557053986240265071537647362089",
        "2442250766561334341166822783674395133995556495312318016431141348749482739749788174173081312927274880146329980363424977565638001056841245678661782610982",
        "917779106114096279364098211126816308037915672568153320523308800097705587686270523428976942621563981845568821206569141624247183330715577260930218556767",
        "214744931049447103852875386182628152420432967632133352449560778740158135437968557572597545037670326240142368149137864407874100658923913041236510842284",
        "3022931024526554241483841300690432083112912011870712018209552253068347592628043101662926263810401378532416655773738499681026278335470355055192240903881",
        "2177879458107855257699914331737144896274676269055062432826552808869348125407671199582563543692287114712642299482144959316835614426673048987634699368975",
        "297233451802123294436846683552230198845414118375785255038220841170372509047202030175469239142902723134737621108313142071558385068315554041062888072990",
    ];
    let a3 = BigVector::from_slice(&a3strvec);
    a3.set_modulus(&q3);
    let b3strvec = vec![
        "1746404952192586268381151521422372143182145525977836700420382237240400642889251297954418325675184427789348433626369450669892557208439401215109489355089",
        "220598825371098531288665964851212313477741334812037568788443848101743931352326362481681721872150902208420539619641973896119680592696228972313317042316",
        "1636408035867347783699588740469182350452165486745277203525427807971352063169622066488977229506420856017031482691439089288020262006748233954177669740311",
        "1391860681743495586446518646883933051685658718352722633694285758474124803847473349064660555618847951719510263829699292297119131926436045214364252430665",
        "840450278810654165061961485691366961514650606247291814263792869596294713810125269780258316551932763106025157596216051681623225968811609560121609943365",
        "2329731862150094912355786583702878434766436140738594274867891494713002534085652731920888891507522355867974791619686673574928137376468103839586921126803",
        "3059472316627396548271906051517665887700234192652488639437431254697285170484189458770168152800520702020313091234437806236204196526193455750117363744648",
        "132216870748476988853044482759545262615616157934129470128771906579101230690441206392939162889560305016204867157725209170345968349185675785497832527174",
    ];
    let b3 = BigVector::from_slice(&b3strvec);
    b3.set_modulus(&q3);
    let modsum3strvec = vec![
        "732016832092609303033733946488851575508905224089926209249817078392018535656765998725014589313481039123037168472673687025432538609494741909227605490712",
        "1699342641679108265957658838484592424389901138210036584743655868072997162880915829271284796618161346407552961175240302978676734578936494043850964404405",
        "805268194532540254853221827315978332231079936014530430473277788624701006514735685778788450107791579012474778927303995844441006517704086579510924761862",
        "2309639787857591865810616858010749359723574390920875954217594558571830391533743872493637498240411933565079085036268433921366315257151622475294470987432",
        "1055195209860101268914836871873995113935083573879425166713353648336452849248093827352855861589603089346167525745353916089497326627735522601358120785649",
        "2079272278780507283826438187565711365662706106566241503594152379685216330309021278700545062992019577249504763265865102246737159166053065841450634441253",
        "1963961166839109935958630686427211631758268415664486282780692695470499499487186103469461604166903659582068706589022694543822554406981111684423535524192",
        "429450322550600283289891166311775461461030276309914725166992747749473739737643236568408402032463028150942488266038351241904353417501229826560720600164",
    ];
    let modsum3 = BigVector::from_slice(&modsum3strvec);
    modsum3.set_modulus(&q3);
    let moddiff3strvec = vec![
        "512597535603578636284620600471706441361256218177317597892343972007351046282937957699448030289016340695226985347494856694864680738501332532337154369965",
        "1258144990936911203380326908782167797434418468585961447166768171869509300176263104307921352873859541990711881935956355186437373393544036099224330319773",
        "805842730693986557467234043205212783543391008567040812905713540778130676580166107684104083420854024129298497671985888277617739050093011724484112870671",
        "2799309032266742562930769261070482408568899000258495476312314409719714580243471729247586479328620187276945241504429920336345307950164925099894493715533",
        "2647685260134934808804103597318860343122424407427906327669059277239997218032517842675609320811641720285003894680481883735468131235997696534443428488350",
        "693199162376459329128054716987553648346475871132117743341660758355345058542390369742037372302879022664441864154051826106098140959002251215605319777078",
        "2391797749376600579441197977047078160791084122445638582872412922268196751328156295695665483217670569843215892375267224089848674446364986290845863213758",
        "165016581053646305583802200792684936229797960441655784909448934591271278356760823782530076253342418118532753950587932901212416719129878255565055545816",
    ];
    let moddiff3 = BigVector::from_slice(&moddiff3strvec);
    moddiff3.set_modulus(&q3);
    let modmul3strvec = vec![
        "1031054745145843056820705945780914118282144310817341310210020640625431998591940403233545109350272933868060509405157360000389345101372898822036359679625",
        "39893990336327654775086201222472749396440031633689107793562292818341559091551650098949141027412374031231642492390533436782802979527602128674296589001",
        "1281575364673380787247887100773933340217543950815953588352031340354110014040347164387450177246143958852636145466379632479296531828035602618716943463922",
        "8876626876958332707488109358602242636976932642794865821404042110211562924605397999217054754859843534043902943791892973269404255881395585577402022234",
        "1216222886905600696846574145744495331189790230286057979942862366975568127231919204120976315097923349074161373380531458334894968146858459205019035261534",
        "753004725575957473234700352714317139479193934162886068369016394155680048439319699359431951178436867519868720662245420487511271148333130090416613227734",
        "2781700410947724700353568488987777429973246834920346616320143955645243949889536315043352628634199412806795883041065539549687937536501039961931401092055",
        "477574462920419903543345320561430691498452711801747910227743781056369739411065806345235440677935972019383967954633150768168291144898135169751571023658",
    ];
    let modmul3 = BigVector::from_slice(&modmul3strvec);
    modmul3.set_modulus(&q3);

    #[cfg(feature = "profile")]
    {
        let mut res: BigVector;
        let mut time2: f64;
        let mut j: usize;

        res = BigVector::new();
        for j in 0..nloop {
            res = a3.clone() + &b3;
        }
        time2 = t3.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t3", nloop, "res", "a3 + b3", time2
        );
        if res != modsum3 {
            println!("Bad res = a3 + b3");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a3.mod_add(&b3);
        }
        time2 = t3.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t3", nloop, "res", "a3.mod_add(b3)", time2
        );
        if res != modsum3 {
            println!("Bad res = a3.mod_add(b3)");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a3.clone() - &b3;
        }
        time2 = t3.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t3", nloop, "res", "a3 - b3", time2
        );
        if res != moddiff3 {
            println!("Bad res = a3 - b3");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a3.mod_sub(&b3);
        }
        time2 = t3.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t3", nloop, "res", "a3.mod_sub(b3)", time2
        );
        if res != moddiff3 {
            println!("Bad res = a3.mod_sub(b3)");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a3.clone() * &b3;
        }
        time2 = t3.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t3", nloop, "res", "a3 * b3", time2
        );
        if res != modmul3 {
            println!("Bad res = a3 * b3");
        }

        res = BigVector::new();
        for j in 0..nloop {
            res = a3.mod_mul(&b3);
        }
        time2 = t3.elapsed().as_micros() as f64;
        println!(
            "{}: {} loops {} = {} computation time: \t{} us",
            "t3", nloop, "res", "a3.mod_mul(b3)", time2
        );
        if res != modmul3 {
            println!("Bad res = a3.mod_mul(b3)");
        }
    }
}

fn main() {
    let args: Vec<String> = std::env::args().collect();
    let nloop: usize = if args.len() > 1 {
        args[1].parse().unwrap_or(10)
    } else {
        10
    };
    println!("running {} nloop = {}", args[0], nloop);
    test_big_vector(nloop);
}